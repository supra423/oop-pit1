So now you're here because you might be wondering how does this work?

Mind that I wrote this file just for my group mates to understand the
program well enough, so they are pretty much the target audience of this
documentation lol

but if you're not one of them, that's fine because
I'm just going to run through the main logic
by explaining the classes and a bit with the GUI.

Take note that this program was created using a more Object-Oriented Approach so
some stuff that I did in this code may be a bit weird like setting all the fields of
classes to be "private" and then defining getters and setter methods for them,
this is just me adhering to OOP design philosophies like encapsulation.

PRODUCTDATA CLASS:
This record class was added pretty late, the only usage of this class is to just reduce
the amount of lines of code in the Inventory class, it is basically just used to store
hardcoded data of the product like the path of the image of that product and its size dimensions.
The ProductData class is used to define instances of the Product class, providing the
name, price, and path to the image associated to that particular product.
Using instances of the ProductData class, I can store them inside an array and iterate
through it using a for loop, significantly reducing the amount of lines.

note: Record classes are classes that already has a canonical constructor,
getters, and other special methods, it is just a fancy way to reduce some
boilerplate.

PRODUCTS CLASS:
Products is also a record class which contains a name, price and icon field,
with a constructor and getter functions. This class is usually
used when displaying product name, price, and icon.

BOUGHTITEM CLASS:
The BoughtItem class only contains a Product type variable and a quantity, the difference
between the BoughtItem class and Product class is that the BoughtItem class is used
when actually handling the purchase itself, I initially thought on placing a quantity field
in the product, but it didn't seem to make that much sense, so I instead created a different
object for it. So whenever a user clicks on a certain product, a pop-up menu should prompt the
user to type in the quantity of the product chosen, after that, an instance of an object
from the BoughtItem class is then created.

ORDER CLASS:
The Order Class contains an ArrayList which stores the BoughtItem objects, and other methods
like calculating the total cost of the order and to reset the ArrayList

INVENTORY CLASS:
The Inventory Class has an array that contains the hardcoded ProductData objects,
The name, prices, imageicon and its dimensions are hardcoded here and then stored
inside an array so that this array will be used to iterate through using a for loop
when it is time to display.

SALESINVENTORY CLASS:
(From commit "68179da595c4a0867e99177a5b495d1aae7ba56d" message)

the SalesInventory class contains a new BoughtItem[]

so everytime the user completes an order, we already know that the
their order gets saved in the ArrayList in the Order class right?
Then, using nested for loops, for every BoughtItem object in the Order
ArrayList, it will get "matched" with a particular object in the array inside
the SalesInventory class, if it matches, then the particular BoughtItem
in the SalesInventory array has its quantity appended, depending
on the quantity of the particular BoughtItem object in the Order
ArrayList

 ##### GUI #####
For the GUI stuff, explaining the entire stuff is hard as hell, you might want to read the modules
Ma'am gave us to at least know half the stuff I'm saying and understand what is going on,

As you can see, in there is this "gui" directory, this is where all the gui components are stored,
inside the gui directory also contain certain subdirectories that are also gui components,

If you noticed it, I structured the gui directory in a form of a hierarchy,
the deeper you go inside the subdirectories of the gui directory, the deeper you are in
the hierarchy. I structured the GUI components the same way!

The "highest" component in the hierarchy is obviously the Window (JFrame),
inside the Window component, there is a single "MainPanel" (JPanel) which also
contains the three major subpanels: LogoPanel, MiddlePanel, BottomPanel (Also JPanels).
These 3 major subpanels also contain their own panels and components!
I treated every single panels as if they are objects,
that's why I created classes for each of them.

You already know where this is all going so I'm not gonna waste my time typing a more
detailed description of the gui directory, just remember that each panels also has subpanels
which also has more subpanels and so on, it is quite a bit complex.

A lot of these subpanels, including components like the buttons have different Layout Managers!
I used GridBagLayout for the Window because when you only place one component inside a GridBagLayout,
it automatically places that component at the center, so in a way I use it as a way to "center"
a certain component, that's why it is the most used layout manager!

The MainPanel uses BorderLayout, it is a convenient layout manager to just dictate which side of
the border you want to "stick" a component to.

For some classes especially the ProductPanel, I used GridLayout which basically stores every component
you add inside a grid with each cell of the grid all having equal dimensions, it kind of
automatically "allocates" space for each component, the difference between GridLayout and GridBagLayout
is that in GridLayout, you can't change the dimensions of each cell inside the grid, it is really
quick to setup the GUI using GridLayout but in exchange for flexibility

While in GridBagLayout, you have more flexibility on how the components are stored inside the grid,
you can have different dimensions for each cell of the grid! It is really handy!
And you can also use the class GridBagConstraints which gives you more flexibility on how
components inside the grid are arranged, another reason why it is the most used layout manager here,
it is pretty much my FAVORITE layout manager.